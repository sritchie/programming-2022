:PROPERTIES:
:Effort:   10
:END:
#+Startup: indent

#+OPTIONS: num:nil reveal_global_footer:t toc:nil reveal_history:t
#+PROPERTY: header-args :eval no-export

#+include: reveal_header.org :minlevel 1

#+Title: Lisp as Renaissance Workshop
#+Subtitle: A Lispy Tour through Mathematical Physics

#+begin_comment
Tasks:

for demos:

- [ ] tidy up the text inside each of the demos. (DONE I think?)

remaining slides

- [ ] after history of vector analysis, matrix vs quaternions slide?
- [ ] get the action formula, brush up on that for the beginning idea
- [ ] quotes from future of education
- [ ] explorables tweet?
- [ ] finish final conclusion slides etc

#+end_comment


* Lisp as Renaissance Workshop
#+begin_notes
Hi, I'm Sam!

Going to talk about sicmutils.
#+end_notes

A Lispy Tour through Mathematical Physics

[[https://samritchie.io/][Sam Ritchie]], Mentat Collective

* SICMUtils
#+begin_notes
- talk is about this library I've been working on...
- Clojure, CAS, many environments, these slides, for one
#+end_notes

#+REVEAL: split
#+begin_src clojure :results value pp :exports both
[(+ (sin 'x) 'x) (+ (sin 12) 2)]
#+end_src

#+RESULTS:
: [(+ (sin x) x) 1.4634270819995652]
:

#+begin_src clojure :results wrap :exports both
(tex$$
 (up (square (cos (* 't 'phi)))
     (floor (* 4 'zeta))))
#+end_src

#+RESULTS:
:results:
$$\begin{pmatrix}\displaystyle{{\cos}^{2}\left(\phi\,t\right)} \cr \cr \displaystyle{\left\lfloor 4\,\zeta \right\rfloor}\end{pmatrix}$$
:end:

#+REVEAL: split
#+begin_src clojure :results wrap :exports both
(let [f (literal-function 'f (-> (UP Real Real) Real))]
  (tex$$
   ((D f) (up 'alpha_1 'alpha_2))))
#+end_src

#+RESULTS:
:results:
$$\begin{bmatrix}\displaystyle{\partial_0f\left(\begin{pmatrix}\displaystyle{{\alpha}_1} \cr \cr \displaystyle{{\alpha}_2}\end{pmatrix}\right)} \cr \cr \displaystyle{\partial_1f\left(\begin{pmatrix}\displaystyle{{\alpha}_1} \cr \cr \displaystyle{{\alpha}_2}\end{pmatrix}\right)}\end{bmatrix}$$
:end:

** ❤️ Open Source ❤️

https://github.com/sicmutils/sicmutils
#+REVEAL_HTML: <img width="100%" src="../images/sicmutils.png">

* Agenda
#+begin_notes
And this idea that CODE can be a fantastic medium for communication. There is so
much promise:

Code is a medium to communicate. But it’s also a medium we use to /build/
systems.

To the extent that the system is self-describing, it also performs itself. So
there is huge promise for the idea of code as communication, and lots of
champions!

But no one really does it. Not much serious publication work as literate files.

WHY, what's missing?
#+end_notes

- Why build another CAS?
- Code as Communication?
- Literate Systems (and their problems)
- Why it matters
- What to do?

* scmutils by GJS
#+begin_notes
- Based on scmutils by GJS
- co-creator of Scheme...
- SICP
#+end_notes

#+REVEAL_HTML: <img class="r-stretch" src="../images/gjs.jpg">

#+REVEAL: split

"*programs must be written for people to read*, and only incidentally for
machines to execute."

#+REVEAL_HTML: <small>~ Hal Abelson, Structure and Interpretation of Computer Programs</small>
#+REVEAL_HTML: <br><img height="300px" src="../images/sicp.jpeg">

* SICM and FDG
#+begin_notes
Followed up SICP with SICM and FDG.

and he's been building this amazing system ever since.
#+end_notes

#+REVEAL_HTML: <img height="500" src="../images/sicm.jpeg">
#+REVEAL_HTML: <img height="500" src="../images/fdg.jpeg">

* Motivation? Google X etc
#+begin_notes
So I thought I'd port it to a browser-environment.

Really fired up on Bret Victor's work, explorable explanations; kill the PDF!

reading all these RL research papers..
#+end_notes

** Disappointment!
#+begin_notes
Then we get to the Google gig. We have this __rot__ going on, where __tools for
thought__ is championed outside the world — often by people that are very
idealistic and thing that this is the way things __should work__ — inherently
gifty, Gift Economy like.

But then the folks using the tools despise the tools. And the toolmakers get
heat for not using them, because it’s so tough. Rare exceptions.

Thrashing around with python and build systems... that is NOT what folks finding
the deep principles behind QM were doing, there is no way it is going to lead to
discoveries here.

No one uses any analogue of lab notebook. Best is snippets pasted into Google
Chat.
#+end_notes

* 19th Century Scientific Communication
#+begin_notes
It didn't used to be this way!

  It's important that these ideas are in the air, that we're proud of them as
  ideas we can take and /use/, not just... oh, tech vibes.
#+end_notes

** History of Vector Analysis
#+begin_notes
Quaternions, Clifford algebra, the battle for representations,

Different than programming language battles, I think.
#+end_notes

#+REVEAL_HTML: <img class="r-stretch" src="../images/vector_analysis.jpeg">

#+REVEAL: split
#+begin_notes
Reminded me of
#+end_notes
#+REVEAL_HTML: <img class="r-stretch" src="../images/lisp_xkcd.jpeg">

* Code as Communication
#+begin_notes
Code is a medium to communicate. But it’s also a medium we use to /build/
systems.

To the extent that the system is self-describing, it also performs itself.

So code should have carried on this legacy, right?
#+end_notes

* Numerical Code as Communication?
#+begin_notes
I did a deep dive into numerical methods and here is what I've found.

I'm going to pick on this one function but scipy is all like this.

example: Brent's algo for univariate minimization.
#+end_notes

"We personally like Brent's algorithm for univariate minimization, as found on
pages 79-80 of his book 'Algorithms for Minimization Without Derivatives'. It is
pretty reliable and pretty fast, *but we cannot explain how it works*."

~ scmutils, /refman.txt/

** Brent's Book, 1973
#+begin_notes
Back to the [[https://maths-people.anu.edu.au/~brent/pub/pub011.html][original book]] from 1973: "Algorithms for Minimization without
Derivatives".
#+end_notes
#+REVEAL_HTML: <img class="r-stretch" src="../images/brent.jpg">

** FORTRAN: Numerical Recipes, 1986
#+begin_notes
1986! [[http://phys.uri.edu/nigh/NumRec/bookfpdf/f10-2.pdf][Numerical Recipes]], pretty good... basically a port.
#+end_notes
#+REVEAL_HTML: <img class="r-stretch" src="../images/numerical_recipes.jpg">

** C++: Boost, 2006
#+begin_notes
Then Boost, C++, comes later, used now:

what's the golden ratio doing in here?
#+end_notes

#+ATTR_REVEAL: :code_attribs data-line-numbers="18|37-41|47-52|56-60|90-98"
#+begin_src cpp
template <class F, class T>
std::pair<T, T> brent_find_minima(F f, T min, T max, int bits, std::uintmax_t& max_iter)
   noexcept(BOOST_MATH_IS_FLOAT(T) && noexcept(std::declval<F>()(std::declval<T>())))
{
   BOOST_MATH_STD_USING
   bits = (std::min)(policies::digits<T, policies::policy<> >() / 2, bits);
   T tolerance = static_cast<T>(ldexp(1.0, 1-bits));
   T x;  // minima so far
   T w;  // second best point
   T v;  // previous value of w
   T u;  // most recent evaluation point
   T delta;  // The distance moved in the last step
   T delta2; // The distance moved in the step before last
   T fu, fv, fw, fx;  // function evaluations at u, v, w, x
   T mid; // midpoint of min and max
   T fract1, fract2;  // minimal relative movement in x

   static const T golden = 0.3819660f;  // golden ratio, don't need too much precision here!

   x = w = v = max;
   fw = fv = fx = f(x);
   delta2 = delta = 0;

   uintmax_t count = max_iter;

   do{
      // get midpoint
      mid = (min + max) / 2;
      // work out if we're done already:
      fract1 = tolerance * fabs(x) + tolerance / 4;
      fract2 = 2 * fract1;
      if(fabs(x - mid) <= (fract2 - (max - min) / 2))
         break;

      if(fabs(delta2) > fract1)
      {
         // try and construct a parabolic fit:
         T r = (x - w) * (fx - fv);
         T q = (x - v) * (fx - fw);
         T p = (x - v) * q - (x - w) * r;
         q = 2 * (q - r);
         if(q > 0)
            p = -p;
         q = fabs(q);
         T td = delta2;
         delta2 = delta;
         // determine whether a parabolic step is acceptable or not:
         if((fabs(p) >= fabs(q * td / 2)) || (p <= q * (min - x)) || (p >= q * (max - x)))
         {
            // nope, try golden section instead
            delta2 = (x >= mid) ? min - x : max - x;
            delta = golden * delta2;
         }
         else
         {
            // whew, parabolic fit:
            delta = p / q;
            u = x + delta;
            if(((u - min) < fract2) || ((max- u) < fract2))
               delta = (mid - x) < 0 ? (T)-fabs(fract1) : (T)fabs(fract1);
         }
      }
      else
      {
         // golden section:
         delta2 = (x >= mid) ? min - x : max - x;
         delta = golden * delta2;
      }
      // update current position:
      u = (fabs(delta) >= fract1) ? T(x + delta) : (delta > 0 ? T(x + fabs(fract1)) : T(x - fabs(fract1)));
      fu = f(u);
      if(fu <= fx)
      {
         // good new point is an improvement!
         // update brackets:
         if(u >= x)
            min = x;
         else
            max = x;
         // update control points:
         v = w;
         w = x;
         x = u;
         fv = fw;
         fw = fx;
         fx = fu;
      }
      else
      {
         // Oh dear, point u is worse than what we have already,
         // even so it *must* be better than one of our endpoints:
         if(u < x)
            min = u;
         else
            max = u;
         if((fu <= fw) || (w == x))
         {
            // however it is at least second best:
            v = w;
            w = u;
            fv = fw;
            fw = fu;
         }
         else if((fu <= fv) || (v == x) || (v == w))
         {
            // third best:
            v = u;
            fv = fu;
         }
      }

   }while(--count);

   max_iter -= count;

   return std::make_pair(x, fx);
}
#+end_src

** Python: Scipy, 2001
#+begin_notes
don't use this, whitespace off

2001? here’s the python version of Brent
https://github.com/scipy/scipy/blob/v1.5.4/scipy/optimize/optimize.py#L2078

And probably delete some of the previous...
#+end_notes

#+ATTR_REVEAL: :code_attribs data-line-numbers="31-42"
#+begin_src python
def optimize(self):
  # set up for optimization
  func = self.func
  xa, xb, xc, fa, fb, fc, funcalls = self.get_bracket_info()
  _mintol = self._mintol
  _cg = self._cg
  #################################
  #BEGIN CORE ALGORITHM
  #################################
  x = w = v = xb
  fw = fv = fx = func(*((x,) + self.args))
  if (xa < xc):
    a = xa
    b = xc
  else:
    a = xc
    b = xa
    deltax = 0.0
    funcalls += 1
    iter = 0
  while (iter < self.maxiter):
    tol1 = self.tol * np.abs(x) + _mintol
    tol2 = 2.0 * tol1
    xmid = 0.5 * (a + b)
    # check for convergence
    if np.abs(x - xmid) < (tol2 - 0.5 * (b - a)):
      break
    # XXX In the first iteration, rat is only bound in the true case
    # of this conditional. This used to cause an UnboundLocalError
    # (gh-4140). It should be set before the if (but to what?).
    if (np.abs(deltax) <= tol1):
      if (x >= xmid):
        deltax = a - x       # do a golden section step
      else:
        deltax = b - x
        rat = _cg * deltax
    else:                              # do a parabolic step
      tmp1 = (x - w) * (fx - fv)
      tmp2 = (x - v) * (fx - fw)
      p = (x - v) * tmp2 - (x - w) * tmp1
      tmp2 = 2.0 * (tmp2 - tmp1)
      if (tmp2 > 0.0):
        p = -p
        tmp2 = np.abs(tmp2)
        dx_temp = deltax
        deltax = rat
        # check parabolic fit
        if ((p > tmp2 * (a - x)) and (p < tmp2 * (b - x)) and
            (np.abs(p) < np.abs(0.5 * tmp2 * dx_temp))):
          rat = p * 1.0 / tmp2        # if parabolic step is useful.
          u = x + rat
          if ((u - a) < tol2 or (b - u) < tol2):
            if xmid - x >= 0:
              rat = tol1
            else:
              rat = -tol1
          else:
            if (x >= xmid):
              deltax = a - x  # if it's not do a golden section step
            else:
              deltax = b - x
              rat = _cg * deltax

      if (np.abs(rat) < tol1):            # update by at least tol1
        if rat >= 0:
          u = x + tol1
        else:
          u = x - tol1
      else:
        u = x + rat
        fu = func(*((u,) + self.args))      # calculate new output value
        funcalls += 1

        if (fu > fx):                 # if it's bigger than current
          if (u < x):
            a = u
          else:
            b = u
          if (fu <= fw) or (w == x):
            v = w
            w = u
            fv = fw
            fw = fu
          elif (fu <= fv) or (v == x) or (v == w):
            v = u
            fv = fu
          else:
            if (u >= x):
              a = x
            else:
              b = x
          v = w
          w = x
          x = u
          fv = fw
          fw = fx
          fx = fu

          iter += 1
 #################################
        #END CORE ALGORITHM
        #################################

        self.xmin = x
        self.fval = fx
        self.iter = iter
        self.funcalls = funcalls
#+end_src

** Scheme: 1987

#+begin_notes
Scheme? NOOO

Mine is better.
#+end_notes

#+ATTR_REVEAL: :code_attribs data-line-numbers="32-43"
#+begin_src scheme
;;; Brent's algorithm for univariate minimization -- transcribed from
;;; pages 79-80 of his book "Algorithms for Minimization Without Derivatives"

(define (brent-min f a b eps)
  (let ((a (min a b)) (b (max a b))
	(maxcount 100)
	(small-bugger-factor *sqrt-machine-epsilon*)
	(g (/ (- 3 (sqrt 5)) 2))
	(d 0) (e 0) (old-e 0) (p 0) (q 0) (u 0) (fu 0))
    (let* ((x (+ a (* g (- b a))))
	   (fx (f x))
	   (w x) (fw fx) (v x) (fv fx))
      (let loop ((count 0))
	(if (> count maxcount)
	    (list 'maxcount x fx count) ;failed to converge
	    (let* ((tol (+ (* eps (abs x)) small-bugger-factor))
		   (2tol (* 2 tol))
		   (m (/ (+ a b) 2)))
	      ;; test for convergence
	      (if (< (max (- x a) (- b x)) 2tol)
		  (list x fx count)
		  (begin
		    (if (> (abs e) tol)
			(let* ((t1 (* (- x w) (- fx fv)))
			       (t2 (* (- x v) (- fx fw)))
			       (t3 (- (* (- x v) t2) (* (- x w) t1)))
			       (t4 (* 2 (- t2 t1))))
			  (set! p (if (positive? t4) (- t3) t3))
			  (set! q (abs t4))
			  (set! old-e e)
			  (set! e d)))
		    (if (and (< (abs p) (abs (* 0.5 q old-e)))
			     (> p (* q (- a x)))
			     (< p (* q (- b x))))
			;; parabolic step
			(begin (set! d (/ p q))
			       (set! u (+ x d))
			       (if (< (min (- u a) (- b u)) 2tol)
				   (set! d (if (< x m) tol (- tol)))))
			;;else, golden section step
			(begin (set! e (if (< x m) (- b x) (- a x)))
			       (set! d (* g e))))
		    (set! u (+ x (if (> (abs d) tol)
				     d
				     (if (positive? d) tol (- tol)))))
		    (set! fu (f u))
		    (if (<= fu fx)
			(begin (if (< u x) (set! b x) (set! a x))
			       (set! v w) (set! fv fw)
			       (set! w x) (set! fw fx)
			       (set! x u) (set! fx fu))
			(begin (if (< u x) (set! a u) (set! b u))
			       (if (or (<= fu fw) (= w x))
				   (begin (set! v w) (set! fv fw)
					  (set! w u) (set! fw fu))
				   (if (or (<= fu fv) (= v x) (= v w))
				       (begin (set! v u) (set! fv fu))))))
		    (loop (+ count 1))))))))))
#+end_src

** Actual Algorithm
#+begin_notes
This is it...

But this image isn't tied to the code! There have been systems to do that... and
the picture is slightly wrong. you really want to watch it proceed.

MEME from Clean Code...
#+end_notes

#+REVEAL_HTML: <img class="r-stretch" src="../images/brent_parabola.png">

** So What?
#+begin_notes
Because these methods are conceptually not that tough, and this is an
improvement on another conceptually easy method. Lots of these are visually very
easy!
#+end_notes

How can we do better?

* Existing Work

#+REVEAL: split data-background="../images/knuth_literate.jpeg"
#+begin_notes
PICK UP HERE:

- what are the other efforts?
Literate programming, of course
#+end_notes

** LOGO
#+begin_notes
Microworlds!
#+end_notes

#+REVEAL_HTML: <img class="r-stretch" src="../images/papert.jpeg">

#+REVEAL: split
#+REVEAL_HTML: <img class="r-stretch" src="../images/turtle_geometry.jpeg">

** Mathematica, Notebooks
#+begin_notes
Mention notebooks here too
#+end_notes

#+REVEAL_HTML: <img width="300" src="../images/mm_notebook.jpg">
#+REVEAL_HTML: <img width="300" src="../images/mathematica.svg">

* Why aren't these working?
#+begin_notes
I am a total sucker for this stuff! But even I don't do it.

If all this is software great, what are we doing?
#+end_notes

#+ATTR_REVEAL: :frag (grow)
- Literate Programming == one-way
- Real Science is Multiplayer
- Dynamic is Too Seductive
- Real Work doesn't happen here

** Literate Programming == one way
#+begin_notes
The problem with Literate Programming is that you really want a culture of
literate programming, so that you can build on all of this stuff together. I’m
imagining something like the AI memos, or email but where everyone is reading in
emacs and you can just fire code around, save it etc. Before all of this version
control nonsense.

ALSO: as a reader, I can't participate in the cultural thing that created the
document!

This is also the problem with notebooks. They are often so dependent on the
user's local environment... I read the thing but it was not designed to be
shared. Yes, I know about Docker etc...

SO — and this is personal for me — I want to bring more of the teaching and
explaining back into real software, into things you can use for real work in a
lab.
#+end_notes

** Real Science is Multiplayer
#+begin_notes
Science is not just about communication. The progression of science has been
inherently multiplayer; so the __nice__ thing about the PDF is you can print it
out and sit in your chair and puzzle over what you’re seeing. And then make
notes in the margins that potentially lead to the next brick in the wall.

A WEAKNESS with existing stuff is that it’s all geared toward presentations.
3b1b style, for example. Brilliant! But it’s a presentation. It’s not a "viewer"
where I can check out my own transformations, play, etc etc
#+end_notes

** Dynamic == Too Seductive
#+begin_notes
It is too seductive, people just want the code to __work__: but the alternative
is what, thrashing around with python code?

Something odd happens when the machine is involved. We GLEEFULLY abstain from
ironing out and understanding it all, because the machine can perform the thing!
Maybe that is like some old-timer in the lab who can work the fridge. But then
we lose the knowledge.
#+end_notes

** People are not doing "real work" in these systems
#+begin_notes
Same with LOGO, with Notebooks. you have to bail out at some point.
#+end_notes

* Why care?
#+begin_notes
These are the crown jewels of our society!

We have many problems left that this computational fluid seems quite useful for.

not to mention that this is a beautiful THING we have figured out how to do,
this sense that abstraction is all around. If it is true of the universe where
we’re living, music, art, wow, better practice.

The ability to do long term projects depends on the transmission of culture over
long distances and times. With our current stuff, the harder the material gets,
the more specialized the field gets, the more impressionistic the notation gets.

How does the way out of the climate crisis, issues like that not depend on
developing a deep intuition around control systems, physical models, physical
simulations and nonlinear feedback?
#+end_notes

** "Future of Education"
#+begin_notes
- [ ] fill in this picture and quote

  We're all quite good at this abstraction thing, but that's not normal!
#+end_notes

- Mythic Understanding
- Romantic Understanding
- *Philosophic Understanding*
- Ironic Understanding

* What to do?
#+begin_notes
#+end_notes

** SICM and FDG as clues
#+begin_notes
these books had actually paved the way! And THAT is the culture I want to soak
up! The hard narrative work is done, for these particular stories.

Browser based, Clojure, Lisp, build on sicm
#+end_notes

#+REVEAL_HTML: <img height="500" src="../images/sicm.jpeg">
#+REVEAL_HTML: <img height="500" src="../images/fdg.jpeg">

#+REVEAL: split data-background="../images/nurse_log.jpeg"
#+begin_notes
Textbook as Nurse Log

Physics and the Book: The Road to Reality. The textbook sort of is a starter
pack. It’s a library already, it’s a nurse tree. It purports to tell you
everything! And in principle it’s all computable and full of abstraction
goodies.

And THAT is the culture I want to soak up!

- We have this grand human tale, over thousands of years, of figuring out how
  the world works. Of how to model reality.

The library that lives in all of these environments, and is fissionable and extensible.

The idea being that the textbook is explicitly about the subject; but actually a
model of exposition, of scientific communication.

And the __exercises__ are an invitation to publish your own original thoughts,
to participate in the discovery process yourself. But often with no way to
practice the publication part. (The discovery has already happened, so why are
we only practicing getting the answer? The goal is to __share__ it in a way that
ignores someone else.)

And the PIECES the library kicks out are usable elsewhere.
#+end_notes

** Explanation as Side Effect
#+begin_notes
Zettelkasten. Then you go tidy it up for someone else.

The dream environment is one where just playing in public leaves a record of
what you did, and is shareable. See Zettelkasten for notes on what to do here.
That was the beauty of the Roam promise.
#+end_notes

* Euler-Lagrange Equations
#+begin_notes
This is a good section to talk about the Sussman pitch on Code as Comms.

Go from:

- Lagrange equations, let's say WHAT WE MEAN
- the expanded version
- the clojure code
- the animation

This has pretty crappy flow now but I think this section is a pretty important
one, to talk about what it MEANS to say that code can communicate.

BY THE WAY, the way you derive this is just bananas, such a great way to THINK.

- [ ] so add a slide about the integral T-V vs where you get...

you'll find you might get sleepy for a few slides; but I will own it by saying
that is kind of the point!

What is interesting here is this fundamentally amazing, beautiful observation.
What is less interesting is the symbol-pushing and accounting /after/ you've
realized.
#+end_notes

$$S[q](t_a, t_b) = D \int_{t_a}^{t_b} L(t, q(t), Dq(t)) dt$$

$$D \int_{t_a}^{t_b} L(t, q(t), Dq(t)) dt = 0$$

#+REVEAL: split
#+ATTR_REVEAL: :frag t :frag_idx 2
"What could this expression possibly mean?"

$${\frac{d}{d t} \frac{\partial L}{\partial \dot{q}}}-\frac{\partial L}{\partial q}=0$$

** Expand:

$${\frac{d}{d t} \frac{\partial L}{\partial \dot{q}}}-\frac{\partial L}{\partial q}=0$$

#+ATTR_REVEAL: :frag t
$$\frac{d}{d t}\left( \left.\frac{\partial L(t, q, \dot{q})}{\partial \dot{q}}
  \right|_{\substack{ {q=w(t)} \\ {\dot{q}=\frac{d w(t)}{d t}} }}
  \right)-\left.\frac{\partial L(t, q, \dot{q})}{\partial q}\right|_{ \substack{
  q=w(t) \\ {\dot{q}=\frac{d w(t)}{d t}}} }=0$$

** Okay, Fine
#+begin_notes
This system lets you write more explicit computational physics.

Development now of the better notation.

Describe "expression derivatives" vs function derivatives.

Culture example:

A PROBLEM here is that these cultures are fairly insular now, because they are
so well developed. So much of the communication occurs in this /shorthand/.

There is so much /culture/.
#+end_notes

$${\frac{d}{d t} \frac{\partial L}{\partial \dot{q}}}-\frac{\partial L}{\partial
q}=0$$

# Notice the trick I had to use to get alignment on the parentheses! On the
# first line, I had to insert \left. and \right. so that I wouldn't be sticking
# a & inside of a pair of delimeters. Ugh!
\begin{align*}
\frac{d}{d t} \left( \right. & \left. \left(\partial_{2} L\right)\left(t, w(t), \frac{d}{d t}
w(t)\right)\right) \\
 - & \left(\partial_{1} L\right)\left(t, w(t), \frac{d}{d t}
w(t)\right) = 0
\end{align*}

** Substitutions
#+begin_notes
So let’s get rid of the expression derivative $d/dt$ and replace it with an
appropriate functional derivative. If $f$ is a function then we will write
$Df$ as the new function that is the derivative of $f$

To do this for the Lagrange equation we need to construct a function to take
the derivative of.

our friend Gamma...
#+end_notes

$$(D f)(t)=\left.\frac{d}{d x} f(x)\right|_{x=t}$$

$$\Gamma[w](t)=\left(t, w(t), \frac{d}{d t} w(t)\right)$$

#+REVEAL: split
#+begin_notes
That lets us simplify a bit more.
Finally, let's get the explicit =t= out of there.
then, program
#+end_notes

#+ATTR_REVEAL: :frag none :frag_idx 1
$$\frac{d}{dt}\left(
\left(\partial_{2} L\right) \left(\Gamma[w](t)\right)
\right) - \left(\partial_{1} L\right) \left(\Gamma[w](t)\right)=0$$

#+ATTR_REVEAL: :frag t :frag_idx 2
$$D\left(\left(\partial_{2} L\right) \circ \left(\Gamma[w]\right)\right)
   \\ -\left(\partial_{1} L\right) \circ \left(\Gamma[w]\right)=0$$

#+ATTR_REVEAL: :frag t :frag_idx 3 :code_attribs data-line-numbers="1|2-4|3|4"
#+begin_src clojure :eval none
(defn Lagrange-equations [L]
  (fn [w]
    (- (D (comp ((partial 2) L) (Gamma w)))
       (comp ((partial 1) L) (Gamma w)))))
#+end_src

#+RESULTS:
: #'prez/Lagrange-equations

#+reveal: split
#+begin_notes
You can look at the general form... but the POINT is that it's
confusing!!!
#+end_notes

#+begin_src clojure :results wrap :exports both :cache yes
(let [L (- (comp (literal-function 'T) velocity)
           (comp (literal-function 'V) coordinate))
      w (literal-function 'w)]
  (tex$$
   (((Lagrange-equations L) w) 't)))
#+end_src

#+RESULTS[b86d9da391958ae3e17a47fae3d7a055e4c153b2]:
:results:
$${D}^{2}w\left(t\right)\,{D}^{2}T\left(Dw\left(t\right)\right) + DV\left(w\left(t\right)\right)$$
:end:

#+REVEAL: split
#+begin_notes
Specific example:

w = angular frequency, radians/second
sqrt(k/m) equals the period for a harmonic oscillator
#+end_notes

#+ATTR_REVEAL: :code_attribs data-line-numbers="7|8"
#+begin_src clojure
(defn L-harmonic
  "Returns a Lagrangian of a simple harmonic oscillator (mass-spring system).

  m is the mass and k is the spring constant used in Hooke's law."
  [m k]
  (fn [[_ q v]]
    (- (* 1/2 m (square v))
       (* 1/2 k (square q)))))
#+end_src

#+RESULTS:
: #'prez/L-harmonic

#+begin_src clojure
(defn proposed-solution [t]
  (* 'a (cos (+ (* 'omega t) 'phi))))
#+end_src

#+RESULTS:
: #'prez/proposed-solution

#+begin_src clojure :results wrap :exports both :cache yes
(let [L (L-harmonic 'm 'k)
      w proposed-solution]
  (tex$$
   (((Lagrange-equations L) w) 't)))
#+end_src

#+RESULTS[4f07f32c756dd28df70e0637cdf4042082d89a06]:
:results:
$$- a\,m\,{\omega}^{2}\,\cos\left(\omega\,t + \phi\right) + a\,k\,\cos\left(\omega\,t + \phi\right)$$
:end:

#+reveal: split
#+begin_notes
Boom, we have F = ma, because F = ma has to be true. So we have Hooke's law
here.
#+end_notes

#+begin_src clojure :results wrap :exports both :cache yes
(let [L (L-harmonic 'm 'k)
      w (literal-function 'w)]
  (tex$$
   (((Lagrange-equations L) w) 't)))
#+end_src

#+RESULTS[35ef84f7fbbe4c6366a9279e07dd2dc9b0454a4b]:
:results:
$$k\,w\left(t\right) + m\,{D}^{2}w\left(t\right)$$
:end:

* Clerk Demo
#+begin_notes
- spring demo
- the physics examples
- function examples
- John video?
- THE LIBRARY ITSELF is written
   - show autodiff, numerical methods
- the slides themselves have math generated by sicmutils
- Nextjournal environment
- Double Pendulum style essay...
- einstein's field equations, pre-load that into the system

Then I'll show you another one that is just bonkers.

- the library itself is written up as a series of computational essays that
  render in the browser.

SO, these "essays" are also little libraries!

You can publish them as little "research papers"
#+end_notes

Let's convince ourselves that that is true, by doing the spring demo in the
browser.

* Community

- Sussman! Wisdom!
- Colin Smith, founded SICMUtils
- Mentat Collective: Brad Feld and John Underkoffler
- Clerk: Martin Kavalar, Jack Rusher, Nextjournal team
- SCI: Michiel Borkent (@borkdude)
- Mathbox: Chris Chudzicki, Steven Wittens

* How to get involved? What's Next?
#+begin_notes
so why is this interesting?

Basically we know the material is good — so how compelling AND SIMULTANEOUSLY
USEFUL can we make the presentation? Fascinating all the way down! the workshop!
#+end_notes

- Collaborative editing, simulation
- Full library as essays
- Steal the pieces!
- Build things like this!

* Conclusion

Lisp, the computational fluid, is something eery and special. It’s not
/everything/; remember, these are just models! But it’s a big deal.

What are we going to do with it?

the whole industry is so frothy, money, excitement, gleefully jettisoning the
original values. Which is all great, of course, except it seems like it’s not
/allowed/ to go work on inspiring stuff, even though there is far more money.

At the same time, what, we’re gonna change the world by working on developer
tools?
